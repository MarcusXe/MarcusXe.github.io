[{"title":"Morse Code","url":"https://xeby.me/2021/02/08/Morse-Code/","content":"International Morse Code(国际莫斯编码)\n以一个点·的长度作为基准1,则划-的长度为3,字母内部的每位之间时间隔长度为1,单词内部字母之间的间隔为3,单词之间间隔为7.\n\n英文字母\n\n\n\n字符\n编码\n字符\n编码\n字符\n编码\n字符\n编码\n字符\n编码\n字符\n编码\n字符\n编码\n\n\n\n\nA\n·-\nB\n-···\nC\n-·-·\nD\n-··\nE\n·\nF\n··-·\nG\n--·\n\n\nH\n····\nI\n··\nJ\n·---\nK\n-·-\nL\n·-··\nM\n--\nN\n-·\n\n\nO\n---\nP\n·--·\nQ\n--·-\nR\n·-·\nS\n···\nT\n-\nU\n··-\n\n\nV\n···-\nW\n·--\nX\n-··-\nY\n-·--\nZ\n--··\n\n\n\n\n\n\n\n数字\n\n\n\n数字\n编码\n数字\n编码\n数字\n编码\n数字\n编码\n数字\n编码\n\n\n\n\n1\n·----\n2\n··---\n3\n···--\n4\n····-\n5\n·····\n\n\n6\n-····\n7\n--···\n8\n---··\n9\n----·\n0\n-----\n\n\n\n\n符号\n\n\n\n符号\n编码\n符号\n编码\n符号\n编码\n符号\n编码\n符号\n编码\n符号\n编码\n\n\n\n\n.\n·-·-·-\n:\n---···\n,\n--··--\n;\n-·-·-·\n?\n··--··\n=\n-···-\n\n\n‘\n·----·\n/\n-··-·\n!\n-·-·--\n-\n-····-\n_\n··--·-\n“\n·-··-·\n\n\n(\n-·--·\n)\n-·--·-\n$\n···-··-\n&amp;\n·-···\n@\n·--·-·\n+\n·-·-·\n\n\n\n\n统一符号\n\n\n\n符号\n\n\n\n\n\n\n\nDE\nTHIS IS FROM\n-·· ·\n表明自己的身份\n\n\n$\\overline{\\text{HH}}$\nError correction\n········\n表示“有错，从上一字重新开始”。\n\n\n$\\overline{\\text{AR}}$\nMessage separator, start new message telegram.\n·-·-·\n本条消息结束\n\n\n$\\overline{\\text{AS}}$\nWait\n·-···\n稍等\n\n\nQTR\nTIME\n--·- - ·-·\n报时消息,后接时间\n\n\nK\nOVER\n-·-\n表示“我已准备好，请开始发送消息”。\n\n\nT\n\n-\n表示“字收到了”。\n\n\n?\nSAY AGAIN\n··--··\n表示“请重复你的电码，我不是很明白”。\n\n\nR\nROGER\n·-·\n表示“消息已收到”。\n\n\n$\\overline{\\text{SK}}$\nEnd of contact\n···-·-\n联系结束\n\n\n$\\overline{\\text{BT}}$\nStart of new section / new paragraph.\n-···-\n分隔符。\n\n\nSOS\nStart of distress signal\n···---···\n求救信号。\n\n\n\n\n","categories":[],"tags":[]},{"title":"kvm on Arch","url":"https://xeby.me/2021/01/26/kvm-on-Arch/","content":"","categories":[],"tags":[]},{"title":"QAPF Graph","url":"https://xeby.me/2021/01/21/QAPF-Graph/","content":"QAPF 图根据IUGS提出的QAPFM分类方案中,铁镁质(mafic)矿物含量体积分数低于90%的岩石根据其所含矿物含量(体积分数)分类,分类参照矿物如下:\n\nQ Quartz/石英石\nA Alkali-Feldspar/碱性长石\nP Plagioclase Feldspar/斜长石\nF Feldspathoids/副长石\n\n岩石的成分与种类的对应关系绘制成菱形的坐标系统,即QAPF图,也被称为Streckeisen图(以原始文章的作者命名)。它由两个三角图(Q,A,P)和(F,A,P)组成,两图以AP边为公共边. 角的顶点代表只由一种长英质岩(felsic)组成, 也即是完全由石英石,碱性长石,斜长石,副长石中某一类矿物组成.\n由于火山岩中的副长石和石英是不共存的，因此QAPF分类始终基于最多3个分量（QAP或APF），即岩石的成分绘制时最终定位在在上部或下部三角形中。\nQAPF图被分成15个基本区域,每个区域都是根据坐标意义下的矿物成分区分不同的岩石.\n两幅QAPF图中,一个用于粗粒（深成岩）或侵入性火成岩，一个用于细粒（火山岩）或喷出性火成岩。 它们大多具有相似的区域划分，因此大多数火山岩具有相应的矿物学等价的深成岩（例如流纹岩和花岗岩）。 某些区域被分配了2到3种岩石类型，可进一步根据其镁铁质矿物含量或斜长石类型（钙质或钠质）加以区分。\n\n本文中 深成岩等价侵入岩,火山岩等价喷出岩,不再进一步区分.\n\n(铁镁质)vol&gt;90%  超铁镁质火成岩\n\n\n\n深成岩\n1 Quartz-Rich Granitoid/富石英花岗岩\n1a Quartzolite/石英岩\n2 Alkali-Feldspar Granite/碱性花岗岩\n3 Granite (3a: Syenogranite - 3b: Monzogranite)/花岗岩(3a:正长花岗岩,3b:二长花岗岩)\n4 Granodiorite/花岗闪长岩\n5 Tonalite/英云闪长岩\n6 Alkali-Feldspar Syenite/碱长正长岩\n6* Quartz-Bearing Alkali-Feldspar Syenite/石英碱长正长岩\n6’ Foid-Bearing Alkali-Feldspar Syenite/含副长石碱长正长岩\n7 Syenite/正长岩\n7* Quartz-Bearing Syenite/石英正长岩\n7’ Foid-Bearing Syenite/含副长石正长岩\n8 Monzonite/二长岩\n8* Quartz-Monzonite/石英二长岩\n8’ Foid-Monzonite/含副长石二长岩\n9 Monzodiorite / Monzogabbro 二长闪长岩/二长辉长岩\n9* Quartz-Monzodiorite / Quartz-Monzogabbro石英二长闪长岩/石英二长辉长岩\n9’ Foid-Monzodiorite / Foid-Monzogabbro 含副长石二长闪长岩/含副长石二长辉长岩\n10 Diorite / Gabbro / Anorthosite 闪长岩/辉长岩/斜长岩\n10* Quartz-Diorite / Quartz-Gabbro 石英闪长岩/石英辉长岩\n10’ Foid-Bearing Diorite / Foid-Bearing Gabbro 含副长石闪长岩/含副长石辉长岩\n11 Foid-Syenite (Foyaite) 副长石正长岩(流霞正长岩)\n12 Foid-Monzosyenite 副长石二长正长岩\n13 Foid-Monzodiorite (Essexite)副长石二长闪长岩(黑斑闪长岩)\n14 Foid-Diorite 副长石闪长岩\n15 Foidolite 副长石岩\n\n\n\n\n火山岩\n1 Not Defined 未定义\n2 Alkali-Feldspar Rhyolite 碱长流纹岩\n3 Rhyolite 流纹岩\n4 Dacite 英安岩\n5 Plagidacite 斜英安岩\n6 Alkali-Feldspar Trachyte 碱长粗面岩\n6* Quartz-Bearing Alkali-Feldspar Trachyte 石英碱长粗面岩\n6’ Foid-Bearing Alkali-Feldspar Trachyte 含副长石碱长粗面岩\n7 Trachyte 粗面岩\n7* Quartz-Trachyte 石英粗面岩\n7’ Foid-Bearing Trachyte 含副长石粗面岩\n8 Latite 安粗岩\n8* Quartz-Latite 石英安粗岩\n8’ Foid-Bearing Latite 含副长石安粗岩\n9 Andesite 安山岩\n9* Quartz-Bearing Andesite  石英安山岩\n9’ Foid-Bearing Andesite  含副长石安山岩\n10 Basalt 玄武岩\n10* Quartz-Bearing Basalt 石英玄武岩\n10’ Foid-Bearing Basalt 含副长石玄武岩\n11 Phonolite 响岩\n12 Tephritic Phonolite 碱玄质响岩\n13 Phonolitic Tephrite / Phonolitic Basanite 响岩质碧玄岩/响岩质碱玄岩/\n14 Tephrite / Basanite 碧玄岩/碱玄岩\n15a Phonolitic Foidite 响岩质副长石岩\n15b Tephritic Foidite 碱玄质副长石岩\n15c Foidite 响岩质副长石岩\n\n\n\n读图方法首先明确此方法仅   $(铁镁矿)_{vol}\\le 90\\%$    的火成岩(深成岩和火山岩).\n\n确定是深成岩还是火成岩,选择对应图.\n确定酸碱性(含石英还是副长石)对应上下三角.\n确定主顶点体积分数(以Q为例)   $\\alpha=\\frac{Q}{A+P}$  ,从Q点对边向上数横线,每条线代表$10\\%$.\n确定剩下成分比例     $\\beta=\\frac{A}{A+P}$   从Q点引射线交与AP边,$6^\\circ$  代表  $10\\%$  .\n交点即为岩石种类.\n\n参考资料:\n","categories":["Geography"],"tags":["Rocks"]},{"title":"同义词(Synonym)","url":"https://xeby.me/2021/01/21/同义词(Synonym)/","content":"同义词(Synonym) 通过同义词可以给表、索引、视图等数据库对象创建一个别名， 来隐藏一些信息，提供一定的安全性 \n 当DBA改变数据库对象的名称时，通过同义词可以避免前台应 用程序的改变 \n 同义词分公有和私有，公有同义词每个用户都能使用，私有同义 词必须具有访问权限的用户才能使\n\n格式\n创建\n\nCREATE [OR REPLACE] [PUBLIC]SYNONYM &lt;同义词名&gt; FOR &lt;对象名&gt; \n\n删除\n\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"存储过程(SP)","url":"https://xeby.me/2021/01/21/存储过程(SP)/","content":"存储过程(SP)存储过程和函数也是一种PL/SQL块，是存入数据库的PL/SQL块。 \n\n但存储过程和函数不同于已经介绍过的PL/SQL程序，我们通常把 PL/SQL程序称为无名（匿名）块，而存储过程和函数是以命名的 方式存储于数据库中的。 \n\n其优点如下：\n简化输入，可以重复执行 \n\n存储过程在服务器端运行，执行速度快\n\n确保数据库的安全性,只有被授权的用户或创建者本身才能执行存 储过程\n\n1. 创建存储过程create [or replace] procedure &lt;过程名&gt; (参数 [in|out|in out] 数据类型，…） is&#x2F;as [declare 变量声明;] begin 执行语句; [exception  异常处理部分]  end;\n\nin表示参数是输入给过程的；\nout表示参数需要在存储过程执行后返回给调用环境一个值；\nin out表示在过程调用时必须给定的并且在执行后返回给调用环境的参\n\n2. 执行存储过程\n方法1：\nEXECUTE 模式名.存储过程名[(参数1,…)];\n模式名即方案名，也就是这个存储过程是属于哪个方案。\n\n方法2： \nBEGIN \n​    模式名.存储过程名[(参数1,…)]; \nEND;用一个匿名的PL/SQL块来执行存储过程。\n\n当含有out型参数时只能使用pl_sql块来实现(在pl_sql块中可以定义变量,作为缓冲区接收回传参数).只含有in类型参数时可以采用excute语句.\n\n\n3. EX\n定义\n\n根据学号和课程号查询学生的成绩信息。\n\nCREATE OR REPLACE PROCEDURE PRO_SELGRADE (stuno in xs.sno%type,stucno in kc.cno%type, stugrade out cj.grade%type) isBEGIN     select grade into stugrade      from cj     where     sno&#x3D;stuno and cno&#x3D;stucno;     exception     when no_data_found then dbms_output.put_line(&#39;数据没找到&#39;);     when others then dbms_output.put_line(&#39;产生异常&#39;); END;\n调用\n查询学号为001221学生的101号课程的成绩信息。\nDECLARE grade cj.grade%type; BEGIN \tpro_selgrade(&#39;001221&#39;,&#39;101&#39;,grade); \tdbms_output.put_line(grade);END;\n\n\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"Exception","url":"https://xeby.me/2021/01/21/异常(Exception)/","content":"Exception1. SYSTEM EXCEPTIONDECLARESTU STUDENT%ROWTYPE;BEGINSELECT * INTO STUFROM STUDENT WHERE SNO=&#x27;201901&#x27;;DBMS_OUTPUT.PUT_LINE(STU.SNAME||&#x27;,&#x27;||STU.SNO);EXCEPTIONWHEN NO_DATA_FOUND THENDBMS_OUTPUT.PUT_LINE(&#x27;FUCK!&#x27;);END;\n\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"索引(Index)","url":"https://xeby.me/2021/01/21/索引(Index)/","content":"索引(Index)1.创建索引方式\n隐式创建：DBMS一般会在创建PRIMARY KEY和UNIQUE约束 列上自动建立索引\n显式创建：使用CREATE INDEX语句创\n\n\n2. 显示创建索引的一般格式CREATE [UNIQUE] INDEX &lt;索引名&gt; ON 表名(&lt;列名&gt; [ASC|DESC]) \n 索引可建立在一列或多列上，各列名之间用逗号分隔 \n ASC(升序)或DESC（降序），指定索引值的排列次序，缺省为ASC\n [UNIQUE]创建唯 一性索引(即如果这一属性值有重复值,无法插入)\n\n报错ORA-01452: cannot CREATE UNIQUE INDEX; duplicate keys found\n\n 索引创建后，由DBMS负责使用和维护\n\n3.删除索引DROP INDEX 索引名\n删除索引时，系统从数据字典中删去有关该索引的描述，同时 从数据区释放索引占用的存储空间\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"关系的完整性约束","url":"https://xeby.me/2021/01/21/约束(Constants)/","content":"关系的完整性约束\n\n\n\n类型\n说明\n\n\n\n\n实体完整性\n约束主键的值\n\n\n参照完整性\n约束外键的值\n\n\n域完整性(用户自定义完整性)\n约束其他字段的值\n\n\n\n\n1. 实体完整性（PRIMARY KEY)\n规则：设属性A是基本关系R的主属性（码的组成部分）， 则属性A不能空值（NULL）和码不能出现重复值。\n\n说明： \n\n实体完整性是针对基本关系的\n实体完整性要求基本关系中的元组在组成码属性上不能有空值 \n现实世界中的实体是可区分的，即它们具有某种唯一性标识（不取重复值)  \n\n\n\n2. 参照（引用）完整性（FOREIGN KEY）\n规则：基本关系R中含有与另一个基本关系S的主码相对应的属性组F （F称为R的外码），则对于R中的每个元组在F上的值必须为： \n或者取空值（F的每个属性值均为空值） \n或者等于S中某个元组的主码值  \n\n\n\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"MIPS32","url":"https://xeby.me/2021/01/21/组成原理/","content":"16位立即数拓展为32位立即数符号拓展即将高位全部置1,无符号拓展即将高位全部置0\n\n\n\n\n16位立即数\n0X8000\n0X1000\n\n\n\n\n符号拓展\n0XFFFF8000\n0XFFFF1000\n\n\n无符号拓展\n0X00008000\n0X00001000\n\n\n\n\nMIPS32指令格式:\nR型\n\n\n\n\n\nop(6bit)\nrs(5bit)\nrt(5bit)\nrd(5bit)\nsa(5bit)\nfunc(6bit)\n\n\n\n\n操作码\n源寄存器1\n源寄存器2\n目标寄存器\n移位位数\n运算码\n\n\n\n\n\nI型\n\n\n\n\n\nop(6bit)\nrs(5bit)\nrt(5bit)\nimmediate(16bit)\n\n\n\n\n操作码\n源寄存器1\n源寄存器2\n立即数\n\n\n\n\n\nJ型\n\n\n\n\n\nop(6bit)\naddress\n\n\n\n\n操作码\n字地址\n\n\n\n\n实现一个MIPS架构的OR指令全局宏定义defines.v\n//全局宏定义`define\tRstEnable\t\t\t\t1&#x27;b1\t\t\t//复位型号有效`define\tRstDisable \t\t\t\t1&#x27;b0`define\tZeroWord\t\t\t\t32&#x27;h00000000\t//32 bit 0`define WriteEnable\t\t\t\t1&#x27;b1`define WriteDisable\t\t\t1&#x27;b0`define ReadEnable\t\t\t\t1&#x27;b1`define ReadDisable\t\t\t\t1&#x27;b0`define AluOpBus\t\t\t\t7:0\t\t\t\t//译码阶段的输出aluop_o的宽度`define AluSelBus\t\t\t\t2:0\t\t\t\t//译码阶段的输出alusel_o的宽度`define InstValid\t\t\t\t1&#x27;b1\t\t\t//instruction Valid`define InstInvalid\t\t\t\t1&#x27;b0\t\t\t//instruction Invalid`define True_v\t\t\t\t\t1&#x27;b1\t\t\t//logic true`define False_v\t\t\t\t\t1&#x27;b0\t\t\t//logic false`define ChipEnable\t\t\t\t1&#x27;b1\t\t`define ChipDisable\t\t\t\t1&#x27;b0\t\t\t//与具体指令有关的宏定义`define EXE_ORI\t\t\t\t\t6&#x27;b001101\t\t//instruction code of ORI`define EXE_NOP\t\t\t\t\t6&#x27;b000000\t\t//instruction code of None inst//Alu_op`define EXE_OR_OP\t\t\t\t8&#x27;b00100101`define EXE_NOP_OP\t\t\t\t8&#x27;b00000000//Alu_sel`define EXE_RES_LOGIC\t\t\t3&#x27;b001`define EXE_RES_NOP\t\t\t\t3&#x27;b000//ROM realted`define InstAddrBus\t\t\t\t31:0\t\t\t//Width of address bus`define InstBus \t\t\t\t31:0\t\t\t//width of data bus`define\tInstMemNum\t\t\t\t131071\t\t\t//128kB`define InstMemNumLog2\t\t\t17\t\t\t\t//actural data bus width(log2..emmmm)//general reg regfile related`define RegAddrBus\t\t\t\t4:0\t\t\t\t//regfile address bus width`define RegBus \t\t\t\t\t31:0\t\t\t//...data bus width`define DoubleRegBus\t\t\t63:0\t\t\t`define RegWidth\t\t\t\t32\t\t\t\t//...bit num`define DoubleRegWidth\t\t\t64`define RegNum\t\t\t\t\t32`define RegNumLog2\t\t\t\t5\t\t\t\t//Width of address bus`define NOPRegAddr\t\t\t\t5&#x27;b00000\n指令寄存器pc_reg.v\n`include &quot;defines.v&quot;module pc_reg(\tinput\twire\t\t\t\tclk,\t//Clock\tinput\twire\t\t\t\trst,\t//reset\toutput\treg[`InstAddrBus] \tpc,\t\t//inst addr\toutput\treg \t\t\t\tce,\t\t//inst mem enable);\talways @(posedge clk) begin\t\tif(rst==`RstEnable) begin\t\t\tce&lt;=`ChipDisable;\t\tend else begin\t\t\tce&lt;=`ChipEnable;\t\tend\tend\talways @(posedge clk) begin\t\tif (ce==`ChipDisable) begin\t\t\tpc&lt;=`ZeroWord;\t\t\t\t\tend\t\telse begin\t\t\tpc&lt;=pc+4&#x27;h4;//Byte addressing\t\tend\tendendmodule\n指令暂存,在下一个时钟周期进行译码if_id.v\n//fetch instruction to decode instruction `incude &quot;defines.v&quot;module if_id(\tinput wire \t\t\t\t\tclk,\tinput wire \t\t\t\t\trst,    input wire [`InstAddrBus]\tif_pc,//inst addr    input wire [`InstBus]\t\tif_inst,//inst from rom..i guess\toutput reg\t[`InstAddrBus]\tid_pc,\toutput reg\t[`InstBus]\t\tid_inst);\talways @(posedge clk)begin\t\tif (rst==`RstEnable) begin\t\t\tid_pc&lt;=`ZeroWord;\t\t\tid_inst&lt;=`ZeroWord;\t\tend else begin\t\t\tid_pc&lt;=if_pc;\t\t\tid_inst&lt;=if_inst;\t\tend\tendendmodule\n寄存器堆,mips规定0号寄存器不给用regfile.v\n`include &quot;defines.v&quot;module regfile(\tinput wire clk,\tinput wire rst,\t//Write port\tinput wire \t\twe,//write enable\tinput wire[`RegAddrBus] \twaddr,\tinput wire[`RegBus]\t\t\twdata,\t//read port 1\tinput wire \t\tre1,//read 1 enable\tinput wire[`RegAddrBus]\t\traddr1,\tinput wire[`RegBus]\t\t\trdata1,\t//read port 2\tinput wire \t\tre2,\tinput wire [`RegAddrBus]\traddr2,\tinput wire [`RegBus]\t\trdata2\t\t);reg[`RegBus]regs[0:`RegNum-1];//write\talways @(posedge clk) begin\t\tif (rst==`RstDisable) begin\t\t\tif((we==`WriteEnable)&amp;&amp;(waddr!=`RegNumLog2&#x27;h0)) begin\t\t\t\tregs[waddr]&lt;=wdata;\t\t\tend\t\t\t\tend\tend//read 1\talways @(*) begin\t\tif (rst==`RstEnable) begin\t\t\trdata1&lt;=`ZeroWord;\t\tend\t\telse if (radddr1==`RegNumLog2&#x27;h0) begin\t\t\trdata1&lt;=`ZeroWord;\t\tend else if((radddr1==waddr)&amp;&amp;(we==`WriteEnable)\t\t\t\t\t\t&amp;&amp;(re1==`ReadEnable)) begin\t\t\trdata1&lt;=wdata;\t\tend else if(re1==`ReadEnable)begin\t\t\trdata1&lt;=regs[raddr1];\t\tend else begin\t\t\trdata1&lt;=`ZeroWord;\t\tend\tend //read 2\talways @(*) begin\t\tif (rst==`RstEnable) begin\t\t\trdata2&lt;=`ZeroWord;\t\tend\t\telse if (radddr2==`RegNumLog2&#x27;h0) begin\t\t\trdata2&lt;=`ZeroWord;\t\tend else if((radddr2==waddr)&amp;&amp;(we==`WriteEnable)\t\t\t\t\t\t&amp;&amp;(re2==`ReadEnable)) begin\t\t\trdata2&lt;=wdata;\t\tend else if(re2==`ReadEnable)begin\t\t\trdata2&lt;=regs[raddr2];\t\tend else begin\t\t\trdata2&lt;=`ZeroWord;\t\tend\tendendmodule\n","categories":["HardWare"],"tags":["Archtacture"]},{"title":"视图(View)","url":"https://xeby.me/2021/01/21/视图(View)/","content":"视图(View) 视图和基本表不同，视图是一种虚拟的表\n 视图是定义在基本表上的，也可以定义在视图上；一个视图可在几 个表或视图上建立，一个表或视图也可建立多个视图 \n 视图只保存查询的定义（语句），而不存储任何数据（结果） \n 视图一经定义，用户就可以把它当作表一样来查询数据\n\n视图可以来自于基本表\n视图也可以来自基本表和视图 \n视图也可以来自于视图\n\n视图定义/创建CREATE [OR REPLACE] VIEW &lt;视图名&gt; [（&lt;列名&gt;[, &lt;列名&gt;]…）] AS &lt;子查询&gt; [WITH CHECK OPTION] [WITH READ ONLY] \n执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的SELECT语句 \n如果子查询中包含有计算列，则必须指定列名（别名），也就是给这一列要起个别名 \nWITH CHECK OPTION表示对视图进行UPDATE和INSERT操作时要保证更新的元组和 新插入的元组满足视图定义中子查询的WHERE子句中的条件表达式 \nWITH READ ONLY用于确保在该视图中没有DML操作被执行【只查看，不更新】 \n12例4：建立计算机系的学生视图student_dept_view例5：把学生的学号及它的平均成绩定义为视图score_avg_viewcreate or replace view student_dept_view as select * from student where dept=’计算机’;create or replace view score_avg_view(sno, avg_grade)  as select sno, round(avg(grade),2) from score group by sno\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"过程语言(PL_SQL)","url":"https://xeby.me/2021/01/21/过程语言(PL_SQL)/","content":"过程语言(PL_SQL)\n列变量\n\nDECLAREstuno student.sno%type;stuname student.sname%TYPE;BEGINSELECT SNO,SNAME INTO STUNO,STUNAMEFROM student WHERE SNO&#x3D;&#39;201901&#39;;DBMS_OUTPUT.PUT_LINE(STUNO||&#39;,&#39;||STUNAME);END; \n\n行变量\n\nDECLARESTU STUDENT%ROWTYPE;BEGINSELECT * INTO STUFROM STUDENT WHERE SNO&#x3D;&#39;201901&#39;;DBMS_OUTPUT.PUT_LINE(STU.SNAME||&#39;,&#39;||STU.SNO);END;\n\n游标变量\n\nDECLARESTU STUDENT%ROWTYPE;BEGINSELECT * INTO STUFROM STUDENT WHERE SNO&#x3D;&#39;201901&#39;;DBMS_OUTPUT.PUT_LINE(STU.SNAME||&#39;,&#39;||STU.SNO);END;declare stu student%rowtype;cursor cur_stu is select * from student;begin OPEN cur_stu;LOOP FETCH CUR_STU INTO STU;EXIT WHEN CUR_STU%NOTFOUND;\n\n隐式游标\n\nbegin     UPDATE student set totalcredit &#x3D;totalcredit*1.5;    if sql%notfound then         dbms_output.putline(sql%rowcount);    end if;end;","categories":["DataBase"],"tags":["Oracle"]},{"title":"触发器(Trigger)","url":"https://xeby.me/2021/01/21/触发器(Trigger)/","content":"触发器(Trigger)\n触发器（Trigger）是一种特殊类型的存储过程。编译后存储在数据 库服务器中。触发器不同于存储过程。存储过程是通过存储过程名字 而被直接调用，而触发器主要是通过事件触发而被系统自动调用执行 的，不是显示执行。\n触发器不接受任何参数，而存储过程需要显示调用，并可以接受和传 回参数。\n触发器通常是与基本表紧密联系在一起的，可以看作是基本表定义的 一部分。触发器是在特定表上进行定义的，该表称为触发器表。当有 针对触发器表的操作时，如在表中插入（Insert）、删除（Delete） 、修改（Update）数据时，触发器就自动触发执行。\n\n\n触发器事件可分为3类：\nDML事件 \n\nDDL事件 \n\n数据库事件\n\n\n\n触发器类型可分为4类： DML触发器 \n DDL触发器 \n 替代触发器 \n 数据库事件触发\n格式CREATE [OR REPLACE] TRIGGER 触发器名 &#123;BEFORE|AFTER|INSTEAD OF&#125; 触发事件1 [OR 触发事件2...]ON 表名 --为哪一张表创建触发器 WHEN 触发条件 --当该条件满足时，触发器才能执行 [FOR EACH ROW] --触发器为行级触发器，即对满足条件的记录触发执行一次 DECLARE \t声明部分 BEGIN \t主体部分 END; \n","categories":["DataBase"],"tags":["Oracle"]},{"title":"LinuxNotes","url":"https://xeby.me/2021/01/18/LinuxNotes/","content":"Zsh\nChinese Characters shows  in the form of it’s code as \\245  ,Zsh is to blame.\n\nAdd \nexport LC_ALL=en_US.UTF-8  export LANG=en_US.UTF-8 \nto .zshrc works.\nxfce4-terminal\nRandom error code on special chars.as ? or other unrecognized form.\n\nChange it’s encoding to Unicode-&gt;UTF 8works.\nLinux kernel(arch as an example)Change kernel\ninstall first.\nmake grub detect it.grub-mkconfig -o /boot/grub/grub.cfg\nReboot to target kernel.\nRemove unnessaries.Done\n\n\nRemove module from kernel.1.mkdir /etc/modprobe.d/vim /etc/modprobe.d/blacklist.confadd !xxxx to this file.\n* build the kernel from scratch works as well,but ….","categories":[],"tags":[]}]