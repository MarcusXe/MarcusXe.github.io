[{"title":"SuiVi","url":"http://www.xeby.me/2021/04/25/SuiVi/","content":"ForHonda Super Cub ","categories":["Skills"],"tags":[]},{"title":"Note","url":"http://www.xeby.me/2021/03/27/Note/","content":"\nXrandr :everyting about Screens.\nRemove /etc/X11\\xorg.confmay fix display problems.\nCuda’problems are all about Dirs.\n\n\n","categories":[],"tags":[]},{"title":"Linux内核损坏修复","url":"http://www.xeby.me/2021/03/09/Linux内核损坏修复/","content":"#起因前几日滚Arch更新内核模块触发内核更新，意外死机，导致内核镜像丢失，fallback镜像也未能幸免。\n#修复S-B-S\n进入grub,normal advanced 均进入失败，内核文件丢失，E进入编辑模式，引导分区在（hd0,gpt7），C进入\n\nGrub Shell，ls (hd0,gpt7)\\确实没有内核文件。\n\n重启进入Windows，从USTC镜像站下载Manjaro镜像，rufus烧进U盘，重启，F12引导U盘启动。\ndolphin查看原来分区里都存了些啥，判断是/ /var /boot /boot /usr等，看不懂的查看/etc/fstab对对照blkid。对比uuid。\nmkdir tmp mount  \\ tmp类推挂载其他分区到相应目录。\n将当前liveusb的/dev /sys /proc目录以--bind参数绑定挂载至以旧系统目录内相应位置（因为当我们切换环境后，这些虚拟文件目录对于不是正常启动的系统来说是个空的或者无法预料的内容，需将当前正常内容作为暂用）\ncd tmp切入要修复系统根目录，chroot .切换运行环境至此，默认root权限，相当于单用户维护模式。\n我是Arch，用的lts内核，pacman -s linux-lts 重新安装内核，其他系统旧apt yum之类的吧，不确定的可以查看/boot/grub/grub.cfg查看内核版本，\n\n然后到boot下能不能找到这个文件。找不到的话可以选择更改grub文件或者重新安装原版本内核。\n\n重启完工。\n\n","categories":["Linux"],"tags":["Arch Manjaro Kernel"]},{"title":"Morse Code","url":"http://www.xeby.me/2021/02/08/Morse-Code/","content":"International Morse Code(国际莫斯编码)\n以一个点·的长度作为基准1,则划-的长度为3,字母内部的每位之间时间隔长度为1,单词内部字母之间的间隔为3,单词之间间隔为7.\n\n英文字母\n\n\n\n字符\n编码\n字符\n编码\n字符\n编码\n字符\n编码\n字符\n编码\n字符\n编码\n字符\n编码\n\n\n\n\nA\n·-\nB\n-···\nC\n-·-·\nD\n-··\nE\n·\nF\n··-·\nG\n--·\n\n\nH\n····\nI\n··\nJ\n·---\nK\n-·-\nL\n·-··\nM\n--\nN\n-·\n\n\nO\n---\nP\n·--·\nQ\n--·-\nR\n·-·\nS\n···\nT\n-\nU\n··-\n\n\nV\n···-\nW\n·--\nX\n-··-\nY\n-·--\nZ\n--··\n\n\n\n\n\n\n\n数字\n\n\n\n数字\n编码\n数字\n编码\n数字\n编码\n数字\n编码\n数字\n编码\n\n\n\n\n1\n·----\n2\n··---\n3\n···--\n4\n····-\n5\n·····\n\n\n6\n-····\n7\n--···\n8\n---··\n9\n----·\n0\n-----\n\n\n\n\n符号\n\n\n\n符号\n编码\n符号\n编码\n符号\n编码\n符号\n编码\n符号\n编码\n符号\n编码\n\n\n\n\n.\n·-·-·-\n:\n---···\n,\n--··--\n;\n-·-·-·\n?\n··--··\n=\n-···-\n\n\n‘\n·----·\n/\n-··-·\n!\n-·-·--\n-\n-····-\n_\n··--·-\n“\n·-··-·\n\n\n(\n-·--·\n)\n-·--·-\n$\n···-··-\n&amp;\n·-···\n@\n·--·-·\n+\n·-·-·\n\n\n\n\n统一符号\n\n\n\n符号\n\n\n\n\n\n\n\nDE\nTHIS IS FROM\n-·· ·\n表明自己的身份\n\n\n$\\overline{\\text{HH}}$\nError correction\n········\n表示“有错，从上一字重新开始”。\n\n\n$\\overline{\\text{AR}}$\nMessage separator, start new message telegram.\n·-·-·\n本条消息结束\n\n\n$\\overline{\\text{AS}}$\nWait\n·-···\n稍等\n\n\nQTR\nTIME\n--·- - ·-·\n报时消息,后接时间\n\n\nK\nOVER\n-·-\n表示“我已准备好，请开始发送消息”。\n\n\nT\n\n-\n表示“字收到了”。\n\n\n?\nSAY AGAIN\n··--··\n表示“请重复你的电码，我不是很明白”。\n\n\nR\nROGER\n·-·\n表示“消息已收到”。\n\n\n$\\overline{\\text{SK}}$\nEnd of contact\n···-·-\n联系结束\n\n\n$\\overline{\\text{BT}}$\nStart of new section / new paragraph.\n-···-\n分隔符。\n\n\nSOS\nStart of distress signal\n···---···\n求救信号。\n\n\n\n\n","categories":[],"tags":[]},{"title":"kvm on Arch","url":"http://www.xeby.me/2021/01/26/kvm-on-Arch/","content":"","categories":[],"tags":[]},{"title":"Advanced Bash-Scripting Guide","url":"http://www.xeby.me/2021/01/22/Advanced Bash-Scripting Guide/","content":"高级Bash脚本指南对Shell编程艺术的深入探讨This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX® wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts .This book is suitable for classroom use as a general introduction to programming concepts.This document is herewith granted to the Public Domain. No copyright!\nDedicationFor Anita, the source of all the magic.\nPart 1. IntroductionScript: A writing; a written document. [Obs.]\n--Webster&#39;s Dictionary, 1913 ed.\nThe shell is a command interpreter. More than just the insulating layer between the operating system kernel and the user, it’s also a fairly powerful programming language. A shell program, called a script, is an easy-to-use tool for building applications by “gluing together” system calls, tools, utilities, and compiled binaries. Virtually the entire repertoire of UNIX commands, utilities, and tools is available for invocation by a shell script. If that were not enough, internal shell commands, such as testing and loop constructs, lend additional power and flexibility to scripts. Shell scripts are especially well suited for administrative system tasks and other routine repetitive tasks not requiring the bells and whistles of a full-blown tightly structured programming language.\nChapter 1. Shell Programming!No programming language is perfect. There is not even a single best language; there are only languages well suited or perhaps poorly suited for particular purposes.     \n--Herbert Mayer\nA working knowledge of shell scripting is essential to anyone wishing to become reasonably proficient at system administration, even if they do not anticipate ever having to actually write a script. Consider that as a Linux machine boots up, it executes the shell scripts in /etc/rc.d to restore the system configuration and set up services. A detailed understanding of these startup scripts is important for analyzing the behavior of a system, and possibly modifying it.\nThe craft of scripting is not hard to master, since scripts can be built in bite-sized sections and there is only a fairly small set of shell-specific operators and options [1] to learn. The syntax is simple — even austere — similar to that of invoking and chaining together utilities at the command line, and there are only a few “rules” governing their use. Most short scripts work right the first time, and debugging even the longer ones is straightforward.\n\n  In the early days of personal computing, the BASIC language enabled  anyone reasonably computer proficient to write programs on an early  generation of microcomputers. Decades later, the Bash scripting  language enables anyone with a rudimentary knowledge of Linux or  UNIX to do the same on modern machines.\n  We now have miniaturized single-board computers with amazing  capabilities, such as the Raspberry Pi.  Bash scripting provides a way to explore the capabilities of these  fascinating devices.\n\nA shell script is a quick-and-dirty method of prototyping a complex application. Getting even a limited subset of the functionality to work in a script is often a useful first stage in project development. In this way, the structure of the application can be tested and tinkered with, and the major pitfalls found before proceeding to the final coding in C, C++, Java, [Perl] or Python.\nShell scripting hearkens back to the classic UNIX philosophy of breaking complex projects into simpler subtasks, of chaining together components and utilities. Many consider this a better, or at least more esthetically pleasing approach to problem solving than using one of the new generation of high-powered all-in-one languages, such as Perl, which attempt to be all things to all people, but at the cost of forcing you to alter your thinking processes to fit the tool.\nAccording to [Herbert Mayer], “a useful language needs arrays, pointers, and a generic mechanism for building data structures.” By these criteria, shell scripting falls somewhat short of being “useful.” Or, perhaps not. . . .\n\nWhen not to use shell scripts\n\nResource-intensive tasks, especially where speed is a factor (sorting, hashing, recursion [2] …)\nProcedures involving heavy-duty math operations, especially floating point arithmetic, arbitrary precision calculations, or complex numbers (use C++ or FORTRAN instead)Cross-platform portability required (use C or Java instead)\nComplex applications, where structured programming is a necessity (type-checking of variables, function prototypes, etc.)\nMission-critical applications upon which you are betting the future of the company\nSituations where security is important, where you need to guarantee the integrity of your system and protect against intrusion, cracking, and vandalism\nProject consists of subcomponents with interlocking dependenciesExtensive file operations required (Bash is limited to serial file access, and that only in a particularly clumsy and inefficient line-by-line fashion.)\nNeed native support for multi-dimensional arrays\nNeed data structures, such as linked lists or trees\nNeed to generate / manipulate graphics or GUIs\nNeed direct access to system hardware or external peripherals\nNeed port or socket I/O\nNeed to use libraries or interface with legacy code\nProprietary, closed-source applications (Shell scripts put the source code right out in the open for all the world to see.)\n\nIf any of the above applies, consider a more powerful scripting language — perhaps Perl, Tcl, Python, Ruby — or possibly a compiled language such as C, C++, or Java. Even then, prototyping the application as a shell script might still be a useful development step.\n\nWe will be using Bash, an acronym [3] for “Bourne-Again shell” and a pun on Stephen Bourne’s now classic Bourne shell. Bash has become a de facto standard for shell scripting on most flavors of UNIX. Most of the principles this book covers apply equally well to scripting with other shells, such as the Korn Shell, from which Bash derives some of its features, [4] and the C Shell and its variants. (Note that C Shell programming is not recommended due to certain inherent problems, as pointed out in an October, 1993 Usenet post by Tom Christiansen.)\nWhat follows is a tutorial on shell scripting. It relies heavily on examples to illustrate various features of the shell. The example scripts work — they’ve been tested, insofar as possible — and some of them are even useful in real life. The reader can play with the actual working code of the examples in the source archive (scriptname.sh or scriptname.bash), [5] give them execute permission (**chmod u+rx scriptname**), then run them to see what happens. Should the source archive not be available, then cut-and-paste from the HTML or pdf rendered versions. Be aware that some of the scripts presented here introduce features before they are explained, and this may require the reader to temporarily skip ahead for enlightenment.\nUnless otherwise noted, [the author](mailto:thegrendel.abs@gmail.com) of this book wrote the example scripts that follow.His countenance was bold and bashed not.**--Edmund Spenser\nNotes\n\n\n\n\n[1]\nThese are referred to as builtins, features internal to the shell.\n\n\n\n\n[2]\nAlthough recursion is possible in a shell script, it tends to be slow and its implementation is often an ugly kludge.\n\n\n[3]\nAn acronym is an ersatz word formed by pasting together the initial letters of the words into a tongue-tripping phrase. This morally corrupt and pernicious practice deserves appropriately severe punishment. Public flogging suggests itself.\n\n\n[4]\nMany of the features of ksh88, and even a few from the updated ksh93 have been merged into Bash.\n\n\n[5]\nBy convention, user-written shell scripts that are Bourne shell compliant generally take a name with a .sh extension. System scripts, such as those found in /etc/rc.d, do not necessarily conform to this nomenclature.\n\n\n\n\nChapter 2. Starting Off With a Sha-BangShell programming is a 1950s juke box . . .--Larry Wall\nIn the simplest case, a script is nothing more than a list of system commands stored in a file. At the very least, this saves the effort of retyping that particular sequence of commands each time it is invoked.\nExample 2-1. *cleanup*: A script to clean up log files in /var/log\n# Cleanup # Run as root, of course. cd /var/log cat /dev/null &gt; messages cat /dev/null &gt; wtmp echo &quot;Log files cleaned up.&quot;\nThere is nothing unusual here, only a set of commands that could just as easily have been invoked one by one from the command-line on the console or in a terminal window. The advantages of placing the commands in a script go far beyond not having to retype them time and again. The script becomes a program — a tool — and it can easily be modified or customized for a particular application.\nExample 2-2. *cleanup*: An improved clean-up script\n#!/bin/bash # Proper header for a Bash script.# Cleanup, version 2 # Run as root, of course.# Insert code here to print error message and exit if not root.LOG_DIR=/var/log # Variables are better than hard-coded values. cd $LOG_DIR cat /dev/null &gt; messages cat /dev/null &gt; wtmp  echo &quot;Logs cleaned up.&quot; exit #  The right and proper method of &quot;exiting&quot; from a script.     #  A bare &quot;exit&quot; (no parameter) returns the exit status     #  of the preceding command. \nNow that’s beginning to look like a real script. But we can go even farther . . .\nExample 2-3. *cleanup*: An enhanced and generalized version of above scripts.\n#!/bin/bash# Cleanup, version 3#  Warning:#  -------#  This script uses quite a number of features that will be explained#+ later on.#  By the time you&#x27;ve finished the first half of the book,#+ there should be nothing mysterious about it.LOG_DIR=/var/logROOT_UID=0     # Only users with $UID 0 have root privileges.LINES=50       # Default number of lines saved.E_XCD=86       # Can&#x27;t change directory?E_NOTROOT=87   # Non-root exit error.# Run as root, of course.if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]then  echo &quot;Must be root to run this script.&quot;  exit $E_NOTROOTfi  if [ -n &quot;$1&quot; ]# Test whether command-line argument is present (non-empty).then  lines=$1else    lines=$LINES # Default, if not specified on command-line.fi  #  Stephane Chazelas suggests the following,#+ as a better way of checking command-line arguments,#+ but this is still a bit advanced for this stage of the tutorial.##    E_WRONGARGS=85  # Non-numerical argument (bad argument format).##    case &quot;$1&quot; in#    &quot;&quot;      ) lines=50;;#    *[!0-9]*) echo &quot;Usage: `basename $0` lines-to-cleanup&quot;;#     exit $E_WRONGARGS;;#    *       ) lines=$1;;#    esac##* Skip ahead to &quot;Loops&quot; chapter to decipher all this.cd $LOG_DIRif [ `pwd` != &quot;$LOG_DIR&quot; ]  # or   if [ &quot;$PWD&quot; != &quot;$LOG_DIR&quot; ]                            # Not in /var/log?then  echo &quot;Can&#x27;t change to $LOG_DIR.&quot;  exit $E_XCDfi  # Doublecheck if in right directory before messing with log file.# Far more efficient is:## cd /var/log || &#123;#   echo &quot;Cannot change to necessary directory.&quot; &gt;&amp;2#   exit $E_XCD;# &#125;tail -n $lines messages &gt; mesg.temp # Save last section of message log file.mv mesg.temp messages               # Rename it as system log file.#  cat /dev/null &gt; messages#* No longer needed, as the above method is safer.cat /dev/null &gt; wtmp  #  &#x27;: &gt; wtmp&#x27; and &#x27;&gt; wtmp&#x27;  have the same effect.echo &quot;Log files cleaned up.&quot;#  Note that there are other log files in /var/log not affected#+ by this script.exit 0#  A zero return value from the script upon exit indicates success#+ to the shell.\nSince you may not wish to wipe out the entire system log, this version of the script keeps the last section of the message log intact. You will constantly discover ways of fine-tuning previously written scripts for increased effectiveness.\n*  \nThe sha-bang ( #!) [1] at the head of a script tells your system that this file is a set of commands to be fed to the command interpreter indicated. The #! is actually a two-byte [2] magic number, a special marker that designates a file type, or in this case an executable shell script (type **man magic** for more details on this fascinating topic). Immediately following the sha-bang is a path name. This is the path to the program that interprets the commands in the script, whether it be a shell, a programming language, or a utility. This command interpreter then executes the commands in the script, starting at the top (the line following the sha-bang line), and ignoring comments. [3]\n#!/bin/sh#!/bin/bash#!/usr/bin/perl#!/usr/bin/tcl#!/bin/sed -f#!/bin/awk -f\nEach of the above script header lines calls a different command interpreter, be it /bin/sh, the default shell (bash in a Linux system) or otherwise. [4] Using **#!/bin/sh**, the default Bourne shell in most commercial variants of UNIX, makes the script portable to non-Linux machines, though you sacrifice Bash-specific features. The script will, however, conform to the POSIX [5] sh standard.\nNote that the path given at the “sha-bang” must be correct, otherwise an error message — usually “Command not found.” — will be the only result of running the script. [6]\n#! can be omitted if the script consists only of a set of generic system commands, using no internal shell directives. The second example, above, requires the initial #!, since the variable assignment line, **lines=50**, uses a shell-specific construct. [7] Note again that **#!/bin/sh** invokes the default shell interpreter, which defaults to /bin/bash on a Linux machine.\n\nThis tutorial encourages a modular approach to constructing a script. Make note of and collect “boilerplate” code snippets that might be useful in future scripts. Eventually you will build quite an extensive library of nifty routines. As an example, the following script prolog tests whether the script has been invoked with the correct number of parameters.\n\nE_WRONG_ARGS=85script_parameters=&quot;-a -h -m -z&quot;#                  -a = all, -h = help, etc.if [ $# -ne $Number_of_expected_args ]then  echo &quot;Usage: `basename $0` $script_parameters&quot;  # `basename $0` is the script&#x27;s filename.  exit $E_WRONG_ARGSfi\n\n Many times, you will write a script that carries out one particular task. The first script in this chapter is an example. Later, it might occur to you to generalize the script to do other, similar tasks. Replacing the literal (“hard-wired”) constants by variables is a step in that direction, as is replacing repetitive code blocks by functions.\n\nNotes\n\n\n\n\n[1]\nMore commonly seen in the literature as she-bang or sh-bang. This derives from the concatenation of the tokens sharp (#) and bang (!).\n\n\n\n\n[2]\nSome flavors of UNIX (those based on 4.2 BSD) allegedly take a four-byte magic number, requiring a blank after the ! — **#! /bin/sh**. According to Sven Mascheck this is probably a myth.\n\n\n[3]\nThe #! line in a shell script will be the first thing the command interpreter (sh or bash) sees. Since this line begins with a #, it will be correctly interpreted as a comment when the command interpreter finally executes the script. The line has already served its purpose - calling the command interpreter.If, in fact, the script includes an extra #! line, then bash will interpret it as a comment.#!/bin/bash echo &quot;Part 1 of script.&quot; a=1 #!/bin/bash # This does *not* launch a new script. echo &quot;Part 2 of script.&quot; echo $a  # Value of $a stays at 1.\n\n\n[4]\nThis allows some cute tricks. `` #!/bin/rm # Self-deleting script. # Nothing much seems to happen when you run this... except that the file disappears. WHATEVER=85 echo &quot;This line will never print (betcha!).&quot; exit $WHATEVER  # Doesn&#39;t matter. The script will not exit here.                # Try an echo $? after script termination.                # You&#39;ll get a 0, not a 85.Also, try starting a README file with a **#!/bin/more**, and making it executable. The result is a self-listing documentation file. (A here document using cat is possibly a better alternative — see Example 19-3).\n\n\n[5]\nPortable Operating System Interface, an attempt to standardize UNIX-like OSes. The POSIX specifications are listed on the Open Group site.\n\n\n[6]\nTo avoid this possibility, a script may begin with a #!/bin/env bash sha-bang line. This may be useful on UNIX machines where bash is not located in /bin\n\n\n[7]\nIf Bash is your default shell, then the #! isn’t necessary at the beginning of a script. However, if launching a script from a different shell, such as tcsh, then you will need the #!.\n\n\n\n\n2.1. Invoking the scriptHaving written the script, you can invoke it by **sh scriptname**, [1] or alternatively **bash scriptname**. (Not recommended is using **sh &lt;scriptname**, since this effectively disables reading from stdin within the script.) Much more convenient is to make the script itself directly executable with a chmod.\nEither:\n​    chmod 555 scriptname (gives everyone read/execute permission) [2]\nor\n​    chmod +rx scriptname (gives everyone read/execute permission)\n​    chmod u+rx scriptname (gives only the script owner read/execute permission)\nHaving made the script executable, you may now test it by **./scriptname**. [3] If it begins with a “sha-bang” line, invoking the script calls the correct command interpreter to run it.\nAs a final step, after testing and debugging, you would likely want to move it to /usr/local/bin (as root, of course), to make the script available to yourself and all other users as a systemwide executable. The script could then be invoked by simply typing scriptname [ENTER] from the command-line.\nNotes\n\n\n\n\n[1]\nCaution: invoking a Bash script by **sh scriptname** turns off Bash-specific extensions, and the script may therefore fail to execute.\n\n\n\n\n[2]\nA script needs read, as well as execute permission for it to run, since the shell needs to be able to read it.\n\n\n[3]\nWhy not simply invoke the script with **scriptname**? If the directory you are in ($PWD) is where 1 is located, why doesn’t this work? This fails because, for security reasons, the current directory (2) is not by default included in a user’s $PATH. It is therefore necessary to explicitly invoke the script in the current directory with a **./scriptname**.\n\n\n\n\n2.2. Preliminary Exercises\nSystem administrators often write scripts to automate common tasks. Give several instances where such scripts would be useful.\nWrite a script that upon invocation shows the time and date, lists all logged-in users, and gives the system uptime. The script then saves this information to a logfile.\n\nPart 2. BasicsChapter 3. Special CharactersWhat makes a character special? If it has a meaning beyond its literal meaning, a meta-meaning, then we refer to it as a special character. Along with commands and keywords, special characters are building blocks of Bash scripts.\nSpecial Characters Found In Scripts and Elsewhere\n\n#\nComments. Lines beginning with a # (with the exception of #!) are comments and will not be executed.\n # This line is a comment.\nComments may also occur following the end of a command.\n\n\n   echo &quot;A comment will follow.&quot; # Comment here. #                            ^ Note whitespace before #\n  Comments may also follow whitespace at the beginning of a line.Comments may also follow whitespace at the beginning of a line.\n  # A tab precedes this comment.\n  Comments may even be embedded within a pipe.\n  initial=( `cat &quot;$startfile&quot; | sed -e &#x27;/#/d&#x27; | tr -d &#x27;\\n&#x27; |\\# Delete lines containing &#x27;#&#x27; comment character.           sed -e &#x27;s/\\./\\. /g&#x27; -e &#x27;s/_/_ /g&#x27;` )# Excerpted from life.sh script\n  A command may not follow a comment on the same line. There is no method of terminating the comment, in order for “live code” to begin on the same line. Use a new line for the next command.\n  Of course, a quoted or an escaped # in an echo statement does not begin a comment. Likewise, a # appears in certain parameter-substitution constructs and in numerical constant expressions.\n  echo &quot;The # here does not begin a comment.&quot;echo &#x27;The # here does not begin a comment.&#x27;echo The \\# here does not begin a comment.echo The # here begins a comment.echo $&#123;PATH#*:&#125;       # Parameter substitution, not a comment.echo $(( 2#101011 ))  # Base conversion, not a comment.# Thanks, S.C.\n  The standard quoting and escape characters (“ ‘ ) escape the #.Certain pattern matching operations also use the #.\n\n;\nCommand separator [semicolon]. Permits putting two or more commands on the same line.\necho hello; echo thereif [ -x &quot;$filename&quot; ]; then    #  Note the space after the semicolon.#+                   ^^  echo &quot;File $filename exists.&quot;; cp $filename $filename.bakelse   #                       ^^  echo &quot;File $filename not found.&quot;; touch $filenamefi; echo &quot;File test complete.&quot;\n\n\n  Note that the “;” sometimes needs to be escaped.\n\n;;\n**Terminator in a case option [double semicolon].\ncase &quot;$variable&quot; in  abc)  echo &quot;\\$variable = abc&quot; ;;  xyz)  echo &quot;\\$variable = xyz&quot; ;;esac\n\n\n\n;;&amp;, ;&amp;\nTerminators in a *case* option (version 4+ of Bash).\n\n.\n“dot” command [period]. Equivalent to source (see Example 15-22). This is a bash builtin.\n\n.\n“dot”, as a component of a filename. When working with filenames, a leading dot is the prefix of a “hidden” file, a file that an ls will not normally show.\nbash$ touch .hidden-filebash$ ls -l\t      total 10 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbookbash$ ls -al\t      total 14 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./ drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../ -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file\t        \n\n\n  When considering directory names, a single dot represents the current working directory, and two dots denote the parent directory.\n  bash$ pwd/home/bozo/projectsbash$ cd .bash$ pwd/home/bozo/projectsbash$ cd ..bash$ pwd/home/bozo/\n  The dot often appears as the destination (directory) of a file movement command, in this context meaning current directory.  \n  bash$ cp /home/bozo/current_work/junk/* .\n  Copy all the “junk” files to $PWD.\n\n.\n“dot” character match. When matching characters, as part of a regular expression, a “dot” matches a single character.\n\n“\npartial quoting [double quote]. “STRING” preserves (from interpretation) most of the special characters within STRING. See Chapter 5.\n\n‘\nfull quoting [single quote]. ‘STRING’ preserves all special characters within STRING. This is a stronger form of quoting than “STRING”. See Chapter 5.\n\n,\ncomma operator. The comma operator [1] links together a series of arithmetic operations. All are evaluated, but only the last one is returned.\nlet &quot;t2 = ((a = 9, 15 / 3))&quot;# Set &quot;a = 9&quot; and &quot;t2 = 15 / 3&quot;\n\n\n  The comma operator can also concatenate strings.\n  for file in /&#123;,usr/&#125;bin/*calc#             ^    Find all executable files ending in &quot;calc&quot;#+                 in /bin and /usr/bin directories.do        if [ -x &quot;$file&quot; ]        then          echo $file        fidone# /bin/ipcalc# /usr/bin/kcalc# /usr/bin/oidcalc# /usr/bin/oocalc# Thank you, Rory Winston, for pointing this out.\n\n,, ,\nLowercase conversion in *parameter substitution* (added in version 4 of Bash).\n\n\\\nescape [backslash]. A quoting mechanism for single characters.**\\X** escapes the character X. This has the effect of “quoting” X, equivalent to ‘X’. The \\ may be used to quote “ and ‘, so they are expressed literally.See Chapter 5 for an in-depth explanation of escaped characters.\n\n/\nFilename path separator [forward slash]. Separates the components of a filename (as in /home/bozo/projects/Makefile).This is also the division arithmetic operator.\n\n`\ncommand substitution. The command construct makes available the output of command for assignment to a variable. This is also known as backquotes or backticks.\n\n:\nnull command [colon]. This is the shell equivalent of a “NOP” (*no op*, a do-nothing operation). It may be considered a synonym for the shell builtin true. The “:” command is itself a Bash builtin, and its exit status is true (0).\n:echo $?   # 0\n\n\n  Endless loop:\n  while :do   operation-1   operation-2   ...   operation-ndone# Same as:#    while true#    do#      ...#    done\n  Placeholder in if/then test:\n  if conditionthen :   # Do nothing and branch aheadelse     # Or else ...   take-some-actionfi\n  Provide a placeholder where a binary operation is expected, see Example 8-2 and default parameters.\n  : $&#123;username=`whoami`&#125;# $&#123;username=`whoami`&#125;   Gives an error without the leading :#                        unless &quot;username&quot; is a command or builtin...: $&#123;1?&quot;Usage: $0 ARGUMENT&quot;&#125;     # From &quot;usage-message.sh example script.\n  Provide a placeholder where a command is expected in a here document. See Example 19-10.Evaluate string of variables using parameter substitution (as in Example 10-7).\n  : $&#123;HOSTNAME?&#125; $&#123;USER?&#125; $&#123;MAIL?&#125;#  Prints error message#+ if one or more of essential environmental variables not set.\n  Variable expansion / substring replacement.In combination with the &gt; redirection operator, truncates a file to zero length, without changing its permissions. If the file did not previously exist, creates it.\n  : &gt; data.xxx   # File &quot;data.xxx&quot; now empty.\t      # Same effect as   cat /dev/null &gt;data.xxx# However, this does not fork a new process, since &quot;:&quot; is a builtin.\n  See also Example 16-15.In combination with the &gt;&gt; redirection operator, has no effect on a pre-existing target file (**: &gt;&gt; target_file**). If the file did not previously exist, creates it.This applies to regular files, not pipes, symlinks, and certain special files.May be used to begin a comment line, although this is not recommended. Using # for a comment turns off error checking for the remainder of that line, so almost anything may appear in a comment. However, this is not the case with :\n  : This is a comment that generates an error, ( if [ $x -eq 3] ).\n  The “:” serves as a field separator, in /etc/passwd, and in the $PATH variable.\n  bash$ echo $PATH/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games\n  A colon is acceptable as a function name.\n  :()&#123;  echo &quot;The name of this function is &quot;$FUNCNAME&quot; &quot;  # Why use a colon as a function name?  # It&#x27;s a way of obfuscating your code.&#125;:# The name of this function is :\n  This is not portable behavior, and therefore not a recommended practice. In fact, more recent releases of Bash do not permit this usage. An underscore _ works, though.A colon can serve as a placeholder in an otherwise empty function.\n  not_empty ()&#123;  :&#125; # Contains a : (null command), and so is not empty.\n\n!\nreverse (or negate) the sense of a test or exit status [bang]. The ! operator inverts the exit status of the command to which it is applied (see Example 6-2). It also inverts the meaning of a test operator. This can, for example, change the sense of equal ( = ) to not-equal ( != ). The ! operator is a Bash keyword.In a different context, the ! also appears in indirect variable references.In yet another context, from the command line, the ! invokes the Bash history mechanism (see Appendix L). Note that within a script, the history mechanism is disabled.\n\n*\nwild card [asterisk]. The * character serves as a “wild card” for filename expansion in globbing. By itself, it matches every filename in a given directory.\nbash$ echo *abs-book.sgml add-drive.sh agram.sh alias.sh\n\n\n  The * also represents any number (or zero) characters in a regular expression.\n\n*\narithmetic operator. In the context of arithmetic operations, the  denotes multiplication.** A double asterisk can represent the exponentiation operator or extended file-match globbing*.\n\n?\ntest operator. Within certain expressions, the ? indicates a test for a condition.In a double-parentheses construct, the ? can serve as an element of a C-style trinary operator. [2]condition?result-if-true:`result-if-false``\n(( var0 = var1&lt;98?9:21 ))#                ^ ^# if [ &quot;$var1&quot; -lt 98 ]: # then#   var0=9# else#   var0=21# fi\n\n\n  a parameter substitution expression, the ? tests whether a variable has been set.\n\n?\nwild card. The ? character serves as a single-character “wild card” for filename expansion in globbing, as well as representing one character in an extended regular expression.\n\n$\nVariable substitution (contents of a variable).\nvar1=5var2=23skidooecho $var1     # 5echo $var2     # 23skidoo\n\n\n  A $ prefixing a variable name indicates the value the variable holds.\n\n$\nend-of-line. In a regular expression, a “$” addresses the end of a line of text.\n\n${}\nParameter substitution.\n\n$’ … ‘\nQuoted string expansion. This construct expands single or multiple escaped octal or hex values into ASCII [3] or Unicode characters.\n\n$*, $@\npositional parameters.\n\n$?\nexit status variable. The $? variable holds the exit status of a command, a function, or of the script itself.\n\n$$\nprocess ID variable. The $$ variable holds the process ID [4] of the script in which it appears.\n\n\n","categories":["Programming Languages"],"tags":["Bash"]},{"title":"QAPF Graph","url":"http://www.xeby.me/2021/01/21/QAPF-Graph/","content":"QAPF 图根据IUGS提出的QAPFM分类方案中,铁镁质(mafic)矿物含量体积分数低于90%的岩石根据其所含矿物含量(体积分数)分类,分类参照矿物如下:\n\nQ Quartz/石英石\nA Alkali-Feldspar/碱性长石\nP Plagioclase Feldspar/斜长石\nF Feldspathoids/副长石\n\n岩石的成分与种类的对应关系绘制成菱形的坐标系统,即QAPF图,也被称为Streckeisen图(以原始文章的作者命名)。它由两个三角图(Q,A,P)和(F,A,P)组成,两图以AP边为公共边. 角的顶点代表只由一种长英质岩(felsic)组成, 也即是完全由石英石,碱性长石,斜长石,副长石中某一类矿物组成.\n由于火山岩中的副长石和石英是不共存的，因此QAPF分类始终基于最多3个分量（QAP或APF），即岩石的成分绘制时最终定位在在上部或下部三角形中。\nQAPF图被分成15个基本区域,每个区域都是根据坐标意义下的矿物成分区分不同的岩石.\n两幅QAPF图中,一个用于粗粒（深成岩）或侵入性火成岩，一个用于细粒（火山岩）或喷出性火成岩。 它们大多具有相似的区域划分，因此大多数火山岩具有相应的矿物学等价的深成岩（例如流纹岩和花岗岩）。 某些区域被分配了2到3种岩石类型，可进一步根据其镁铁质矿物含量或斜长石类型（钙质或钠质）加以区分。\n\n本文中 深成岩等价侵入岩,火山岩等价喷出岩,不再进一步区分.\n\n(铁镁质)vol&gt;90%  超铁镁质火成岩\n\n\n\n深成岩\n1 Quartz-Rich Granitoid/富石英花岗岩\n1a Quartzolite/石英岩\n2 Alkali-Feldspar Granite/碱性花岗岩\n3 Granite (3a: Syenogranite - 3b: Monzogranite)/花岗岩(3a:正长花岗岩,3b:二长花岗岩)\n4 Granodiorite/花岗闪长岩\n5 Tonalite/英云闪长岩\n6 Alkali-Feldspar Syenite/碱长正长岩\n6* Quartz-Bearing Alkali-Feldspar Syenite/石英碱长正长岩\n6’ Foid-Bearing Alkali-Feldspar Syenite/含副长石碱长正长岩\n7 Syenite/正长岩\n7* Quartz-Bearing Syenite/石英正长岩\n7’ Foid-Bearing Syenite/含副长石正长岩\n8 Monzonite/二长岩\n8* Quartz-Monzonite/石英二长岩\n8’ Foid-Monzonite/含副长石二长岩\n9 Monzodiorite / Monzogabbro 二长闪长岩/二长辉长岩\n9* Quartz-Monzodiorite / Quartz-Monzogabbro石英二长闪长岩/石英二长辉长岩\n9’ Foid-Monzodiorite / Foid-Monzogabbro 含副长石二长闪长岩/含副长石二长辉长岩\n10 Diorite / Gabbro / Anorthosite 闪长岩/辉长岩/斜长岩\n10* Quartz-Diorite / Quartz-Gabbro 石英闪长岩/石英辉长岩\n10’ Foid-Bearing Diorite / Foid-Bearing Gabbro 含副长石闪长岩/含副长石辉长岩\n11 Foid-Syenite (Foyaite) 副长石正长岩(流霞正长岩)\n12 Foid-Monzosyenite 副长石二长正长岩\n13 Foid-Monzodiorite (Essexite)副长石二长闪长岩(黑斑闪长岩)\n14 Foid-Diorite 副长石闪长岩\n15 Foidolite 副长石岩\n\n\n\n\n火山岩\n1 Not Defined 未定义\n2 Alkali-Feldspar Rhyolite 碱长流纹岩\n3 Rhyolite 流纹岩\n4 Dacite 英安岩\n5 Plagidacite 斜英安岩\n6 Alkali-Feldspar Trachyte 碱长粗面岩\n6* Quartz-Bearing Alkali-Feldspar Trachyte 石英碱长粗面岩\n6’ Foid-Bearing Alkali-Feldspar Trachyte 含副长石碱长粗面岩\n7 Trachyte 粗面岩\n7* Quartz-Trachyte 石英粗面岩\n7’ Foid-Bearing Trachyte 含副长石粗面岩\n8 Latite 安粗岩\n8* Quartz-Latite 石英安粗岩\n8’ Foid-Bearing Latite 含副长石安粗岩\n9 Andesite 安山岩\n9* Quartz-Bearing Andesite  石英安山岩\n9’ Foid-Bearing Andesite  含副长石安山岩\n10 Basalt 玄武岩\n10* Quartz-Bearing Basalt 石英玄武岩\n10’ Foid-Bearing Basalt 含副长石玄武岩\n11 Phonolite 响岩\n12 Tephritic Phonolite 碱玄质响岩\n13 Phonolitic Tephrite / Phonolitic Basanite 响岩质碧玄岩/响岩质碱玄岩/\n14 Tephrite / Basanite 碧玄岩/碱玄岩\n15a Phonolitic Foidite 响岩质副长石岩\n15b Tephritic Foidite 碱玄质副长石岩\n15c Foidite 响岩质副长石岩\n\n\n\n读图方法首先明确此方法仅   $(铁镁矿)_{vol}\\le 90\\%$    的火成岩(深成岩和火山岩).\n\n确定是深成岩还是火成岩,选择对应图.\n确定酸碱性(含石英还是副长石)对应上下三角.\n确定主顶点体积分数(以Q为例)   $\\alpha=\\frac{Q}{A+P}$  ,从Q点对边向上数横线,每条线代表$10\\%$.\n确定剩下成分比例     $\\beta=\\frac{A}{A+P}$   从Q点引射线交与AP边,$6^\\circ$  代表  $10\\%$  .\n交点即为岩石种类.\n\n参考资料:\n","categories":["Geography"],"tags":["Rocks"]},{"title":"存储过程(SP)","url":"http://www.xeby.me/2021/01/21/存储过程(SP)/","content":"存储过程(SP)存储过程和函数也是一种PL/SQL块，是存入数据库的PL/SQL块。 \n\n但存储过程和函数不同于已经介绍过的PL/SQL程序，我们通常把 PL/SQL程序称为无名（匿名）块，而存储过程和函数是以命名的 方式存储于数据库中的。 \n\n其优点如下：\n简化输入，可以重复执行 \n\n存储过程在服务器端运行，执行速度快\n\n确保数据库的安全性,只有被授权的用户或创建者本身才能执行存 储过程\n\n1. 创建存储过程create [or replace] procedure &lt;过程名&gt; (参数 [in|out|in out] 数据类型，…） is&#x2F;as [declare 变量声明;] begin 执行语句; [exception  异常处理部分]  end;\n\nin表示参数是输入给过程的；\nout表示参数需要在存储过程执行后返回给调用环境一个值；\nin out表示在过程调用时必须给定的并且在执行后返回给调用环境的参\n\n2. 执行存储过程\n方法1：\nEXECUTE 模式名.存储过程名[(参数1,…)];\n模式名即方案名，也就是这个存储过程是属于哪个方案。\n\n方法2： \nBEGIN \n​    模式名.存储过程名[(参数1,…)]; \nEND;用一个匿名的PL/SQL块来执行存储过程。\n\n当含有out型参数时只能使用pl_sql块来实现(在pl_sql块中可以定义变量,作为缓冲区接收回传参数).只含有in类型参数时可以采用excute语句.\n\n\n3. EX\n定义\n\n根据学号和课程号查询学生的成绩信息。\n\nCREATE OR REPLACE PROCEDURE PRO_SELGRADE (stuno in xs.sno%type,stucno in kc.cno%type, stugrade out cj.grade%type) isBEGIN     select grade into stugrade      from cj     where     sno&#x3D;stuno and cno&#x3D;stucno;     exception     when no_data_found then dbms_output.put_line(&#39;数据没找到&#39;);     when others then dbms_output.put_line(&#39;产生异常&#39;); END;\n调用\n查询学号为001221学生的101号课程的成绩信息。\nDECLARE grade cj.grade%type; BEGIN \tpro_selgrade(&#39;001221&#39;,&#39;101&#39;,grade); \tdbms_output.put_line(grade);END;\n\n\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"同义词(Synonym)","url":"http://www.xeby.me/2021/01/21/同义词(Synonym)/","content":"同义词(Synonym) 通过同义词可以给表、索引、视图等数据库对象创建一个别名， 来隐藏一些信息，提供一定的安全性 \n 当DBA改变数据库对象的名称时，通过同义词可以避免前台应 用程序的改变 \n 同义词分公有和私有，公有同义词每个用户都能使用，私有同义 词必须具有访问权限的用户才能使\n\n格式\n创建\n\nCREATE [OR REPLACE] [PUBLIC]SYNONYM &lt;同义词名&gt; FOR &lt;对象名&gt; \n\n删除\n\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"Exception","url":"http://www.xeby.me/2021/01/21/异常(Exception)/","content":"Exception1. SYSTEM EXCEPTIONDECLARESTU STUDENT%ROWTYPE;BEGINSELECT * INTO STUFROM STUDENT WHERE SNO=&#x27;201901&#x27;;DBMS_OUTPUT.PUT_LINE(STU.SNAME||&#x27;,&#x27;||STU.SNO);EXCEPTIONWHEN NO_DATA_FOUND THENDBMS_OUTPUT.PUT_LINE(&#x27;FUCK!&#x27;);END;\n\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"索引(Index)","url":"http://www.xeby.me/2021/01/21/索引(Index)/","content":"索引(Index)1.创建索引方式\n隐式创建：DBMS一般会在创建PRIMARY KEY和UNIQUE约束 列上自动建立索引\n显式创建：使用CREATE INDEX语句创\n\n\n2. 显示创建索引的一般格式CREATE [UNIQUE] INDEX &lt;索引名&gt; ON 表名(&lt;列名&gt; [ASC|DESC]) \n 索引可建立在一列或多列上，各列名之间用逗号分隔 \n ASC(升序)或DESC（降序），指定索引值的排列次序，缺省为ASC\n [UNIQUE]创建唯 一性索引(即如果这一属性值有重复值,无法插入)\n\n报错ORA-01452: cannot CREATE UNIQUE INDEX; duplicate keys found\n\n 索引创建后，由DBMS负责使用和维护\n\n3.删除索引DROP INDEX 索引名\n删除索引时，系统从数据字典中删去有关该索引的描述，同时 从数据区释放索引占用的存储空间\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"关系的完整性约束","url":"http://www.xeby.me/2021/01/21/约束(Constants)/","content":"关系的完整性约束\n\n\n\n类型\n说明\n\n\n\n\n实体完整性\n约束主键的值\n\n\n参照完整性\n约束外键的值\n\n\n域完整性(用户自定义完整性)\n约束其他字段的值\n\n\n\n\n1. 实体完整性（PRIMARY KEY)\n规则：设属性A是基本关系R的主属性（码的组成部分）， 则属性A不能空值（NULL）和码不能出现重复值。\n\n说明： \n\n实体完整性是针对基本关系的\n实体完整性要求基本关系中的元组在组成码属性上不能有空值 \n现实世界中的实体是可区分的，即它们具有某种唯一性标识（不取重复值)  \n\n\n\n2. 参照（引用）完整性（FOREIGN KEY）\n规则：基本关系R中含有与另一个基本关系S的主码相对应的属性组F （F称为R的外码），则对于R中的每个元组在F上的值必须为： \n或者取空值（F的每个属性值均为空值） \n或者等于S中某个元组的主码值  \n\n\n\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"MIPS32","url":"http://www.xeby.me/2021/01/21/组成原理/","content":"16位立即数拓展为32位立即数符号拓展即将高位全部置1,无符号拓展即将高位全部置0\n\n\n\n\n16位立即数\n0X8000\n0X1000\n\n\n\n\n符号拓展\n0XFFFF8000\n0XFFFF1000\n\n\n无符号拓展\n0X00008000\n0X00001000\n\n\n\n\nMIPS32指令格式:\nR型\n\n\n\n\n\nop(6bit)\nrs(5bit)\nrt(5bit)\nrd(5bit)\nsa(5bit)\nfunc(6bit)\n\n\n\n\n操作码\n源寄存器1\n源寄存器2\n目标寄存器\n移位位数\n运算码\n\n\n\n\n\nI型\n\n\n\n\n\nop(6bit)\nrs(5bit)\nrt(5bit)\nimmediate(16bit)\n\n\n\n\n操作码\n源寄存器1\n源寄存器2\n立即数\n\n\n\n\n\nJ型\n\n\n\n\n\nop(6bit)\naddress\n\n\n\n\n操作码\n字地址\n\n\n\n\n实现一个MIPS架构的OR指令全局宏定义defines.v\n//全局宏定义`define\tRstEnable\t\t\t\t1&#x27;b1\t\t\t//复位型号有效`define\tRstDisable \t\t\t\t1&#x27;b0`define\tZeroWord\t\t\t\t32&#x27;h00000000\t//32 bit 0`define WriteEnable\t\t\t\t1&#x27;b1`define WriteDisable\t\t\t1&#x27;b0`define ReadEnable\t\t\t\t1&#x27;b1`define ReadDisable\t\t\t\t1&#x27;b0`define AluOpBus\t\t\t\t7:0\t\t\t\t//译码阶段的输出aluop_o的宽度`define AluSelBus\t\t\t\t2:0\t\t\t\t//译码阶段的输出alusel_o的宽度`define InstValid\t\t\t\t1&#x27;b1\t\t\t//instruction Valid`define InstInvalid\t\t\t\t1&#x27;b0\t\t\t//instruction Invalid`define True_v\t\t\t\t\t1&#x27;b1\t\t\t//logic true`define False_v\t\t\t\t\t1&#x27;b0\t\t\t//logic false`define ChipEnable\t\t\t\t1&#x27;b1\t\t`define ChipDisable\t\t\t\t1&#x27;b0\t\t\t//与具体指令有关的宏定义`define EXE_ORI\t\t\t\t\t6&#x27;b001101\t\t//instruction code of ORI`define EXE_NOP\t\t\t\t\t6&#x27;b000000\t\t//instruction code of None inst//Alu_op`define EXE_OR_OP\t\t\t\t8&#x27;b00100101`define EXE_NOP_OP\t\t\t\t8&#x27;b00000000//Alu_sel`define EXE_RES_LOGIC\t\t\t3&#x27;b001`define EXE_RES_NOP\t\t\t\t3&#x27;b000//ROM realted`define InstAddrBus\t\t\t\t31:0\t\t\t//Width of address bus`define InstBus \t\t\t\t31:0\t\t\t//width of data bus`define\tInstMemNum\t\t\t\t131071\t\t\t//128kB`define InstMemNumLog2\t\t\t17\t\t\t\t//actural data bus width(log2..emmmm)//general reg regfile related`define RegAddrBus\t\t\t\t4:0\t\t\t\t//regfile address bus width`define RegBus \t\t\t\t\t31:0\t\t\t//...data bus width`define DoubleRegBus\t\t\t63:0\t\t\t`define RegWidth\t\t\t\t32\t\t\t\t//...bit num`define DoubleRegWidth\t\t\t64`define RegNum\t\t\t\t\t32`define RegNumLog2\t\t\t\t5\t\t\t\t//Width of address bus`define NOPRegAddr\t\t\t\t5&#x27;b00000\n指令寄存器pc_reg.v\n`include &quot;defines.v&quot;module pc_reg(\tinput\twire\t\t\t\tclk,\t//Clock\tinput\twire\t\t\t\trst,\t//reset\toutput\treg[`InstAddrBus] \tpc,\t\t//inst addr\toutput\treg \t\t\t\tce,\t\t//inst mem enable);\talways @(posedge clk) begin\t\tif(rst==`RstEnable) begin\t\t\tce&lt;=`ChipDisable;\t\tend else begin\t\t\tce&lt;=`ChipEnable;\t\tend\tend\talways @(posedge clk) begin\t\tif (ce==`ChipDisable) begin\t\t\tpc&lt;=`ZeroWord;\t\t\t\t\tend\t\telse begin\t\t\tpc&lt;=pc+4&#x27;h4;//Byte addressing\t\tend\tendendmodule\n指令暂存,在下一个时钟周期进行译码if_id.v\n//fetch instruction to decode instruction `incude &quot;defines.v&quot;module if_id(\tinput wire \t\t\t\t\tclk,\tinput wire \t\t\t\t\trst,    input wire [`InstAddrBus]\tif_pc,//inst addr    input wire [`InstBus]\t\tif_inst,//inst from rom..i guess\toutput reg\t[`InstAddrBus]\tid_pc,\toutput reg\t[`InstBus]\t\tid_inst);\talways @(posedge clk)begin\t\tif (rst==`RstEnable) begin\t\t\tid_pc&lt;=`ZeroWord;\t\t\tid_inst&lt;=`ZeroWord;\t\tend else begin\t\t\tid_pc&lt;=if_pc;\t\t\tid_inst&lt;=if_inst;\t\tend\tendendmodule\n寄存器堆,mips规定0号寄存器不给用regfile.v\n`include &quot;defines.v&quot;module regfile(\tinput wire clk,\tinput wire rst,\t//Write port\tinput wire \t\twe,//write enable\tinput wire[`RegAddrBus] \twaddr,\tinput wire[`RegBus]\t\t\twdata,\t//read port 1\tinput wire \t\tre1,//read 1 enable\tinput wire[`RegAddrBus]\t\traddr1,\tinput wire[`RegBus]\t\t\trdata1,\t//read port 2\tinput wire \t\tre2,\tinput wire [`RegAddrBus]\traddr2,\tinput wire [`RegBus]\t\trdata2\t\t);reg[`RegBus]regs[0:`RegNum-1];//write\talways @(posedge clk) begin\t\tif (rst==`RstDisable) begin\t\t\tif((we==`WriteEnable)&amp;&amp;(waddr!=`RegNumLog2&#x27;h0)) begin\t\t\t\tregs[waddr]&lt;=wdata;\t\t\tend\t\t\t\tend\tend//read 1\talways @(*) begin\t\tif (rst==`RstEnable) begin\t\t\trdata1&lt;=`ZeroWord;\t\tend\t\telse if (radddr1==`RegNumLog2&#x27;h0) begin\t\t\trdata1&lt;=`ZeroWord;\t\tend else if((radddr1==waddr)&amp;&amp;(we==`WriteEnable)\t\t\t\t\t\t&amp;&amp;(re1==`ReadEnable)) begin\t\t\trdata1&lt;=wdata;\t\tend else if(re1==`ReadEnable)begin\t\t\trdata1&lt;=regs[raddr1];\t\tend else begin\t\t\trdata1&lt;=`ZeroWord;\t\tend\tend //read 2\talways @(*) begin\t\tif (rst==`RstEnable) begin\t\t\trdata2&lt;=`ZeroWord;\t\tend\t\telse if (radddr2==`RegNumLog2&#x27;h0) begin\t\t\trdata2&lt;=`ZeroWord;\t\tend else if((radddr2==waddr)&amp;&amp;(we==`WriteEnable)\t\t\t\t\t\t&amp;&amp;(re2==`ReadEnable)) begin\t\t\trdata2&lt;=wdata;\t\tend else if(re2==`ReadEnable)begin\t\t\trdata2&lt;=regs[raddr2];\t\tend else begin\t\t\trdata2&lt;=`ZeroWord;\t\tend\tendendmodule\n","categories":["HardWare"],"tags":["Archtacture"]},{"title":"视图(View)","url":"http://www.xeby.me/2021/01/21/视图(View)/","content":"视图(View) 视图和基本表不同，视图是一种虚拟的表\n 视图是定义在基本表上的，也可以定义在视图上；一个视图可在几 个表或视图上建立，一个表或视图也可建立多个视图 \n 视图只保存查询的定义（语句），而不存储任何数据（结果） \n 视图一经定义，用户就可以把它当作表一样来查询数据\n\n视图可以来自于基本表\n视图也可以来自基本表和视图 \n视图也可以来自于视图\n\n视图定义/创建CREATE [OR REPLACE] VIEW &lt;视图名&gt; [（&lt;列名&gt;[, &lt;列名&gt;]…）] AS &lt;子查询&gt; [WITH CHECK OPTION] [WITH READ ONLY] \n执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的SELECT语句 \n如果子查询中包含有计算列，则必须指定列名（别名），也就是给这一列要起个别名 \nWITH CHECK OPTION表示对视图进行UPDATE和INSERT操作时要保证更新的元组和 新插入的元组满足视图定义中子查询的WHERE子句中的条件表达式 \nWITH READ ONLY用于确保在该视图中没有DML操作被执行【只查看，不更新】 \n12例4：建立计算机系的学生视图student_dept_view例5：把学生的学号及它的平均成绩定义为视图score_avg_viewcreate or replace view student_dept_view as select * from student where dept=’计算机’;create or replace view score_avg_view(sno, avg_grade)  as select sno, round(avg(grade),2) from score group by sno\n","categories":["DataBase"],"tags":["Oracle"]},{"title":"过程语言(PL_SQL)","url":"http://www.xeby.me/2021/01/21/过程语言(PL_SQL)/","content":"过程语言(PL_SQL)\n列变量\n\nDECLAREstuno student.sno%type;stuname student.sname%TYPE;BEGINSELECT SNO,SNAME INTO STUNO,STUNAMEFROM student WHERE SNO&#x3D;&#39;201901&#39;;DBMS_OUTPUT.PUT_LINE(STUNO||&#39;,&#39;||STUNAME);END; \n\n行变量\n\nDECLARESTU STUDENT%ROWTYPE;BEGINSELECT * INTO STUFROM STUDENT WHERE SNO&#x3D;&#39;201901&#39;;DBMS_OUTPUT.PUT_LINE(STU.SNAME||&#39;,&#39;||STU.SNO);END;\n\n游标变量\n\nDECLARESTU STUDENT%ROWTYPE;BEGINSELECT * INTO STUFROM STUDENT WHERE SNO&#x3D;&#39;201901&#39;;DBMS_OUTPUT.PUT_LINE(STU.SNAME||&#39;,&#39;||STU.SNO);END;declare stu student%rowtype;cursor cur_stu is select * from student;begin OPEN cur_stu;LOOP FETCH CUR_STU INTO STU;EXIT WHEN CUR_STU%NOTFOUND;\n\n隐式游标\n\nbegin     UPDATE student set totalcredit &#x3D;totalcredit*1.5;    if sql%notfound then         dbms_output.putline(sql%rowcount);    end if;end;","categories":["DataBase"],"tags":["Oracle"]},{"title":"触发器(Trigger)","url":"http://www.xeby.me/2021/01/21/触发器(Trigger)/","content":"触发器(Trigger)\n触发器（Trigger）是一种特殊类型的存储过程。编译后存储在数据 库服务器中。触发器不同于存储过程。存储过程是通过存储过程名字 而被直接调用，而触发器主要是通过事件触发而被系统自动调用执行 的，不是显示执行。\n触发器不接受任何参数，而存储过程需要显示调用，并可以接受和传 回参数。\n触发器通常是与基本表紧密联系在一起的，可以看作是基本表定义的 一部分。触发器是在特定表上进行定义的，该表称为触发器表。当有 针对触发器表的操作时，如在表中插入（Insert）、删除（Delete） 、修改（Update）数据时，触发器就自动触发执行。\n\n\n触发器事件可分为3类：\nDML事件 \n\nDDL事件 \n\n数据库事件\n\n\n\n触发器类型可分为4类： DML触发器 \n DDL触发器 \n 替代触发器 \n 数据库事件触发\n格式CREATE [OR REPLACE] TRIGGER 触发器名 &#123;BEFORE|AFTER|INSTEAD OF&#125; 触发事件1 [OR 触发事件2...]ON 表名 --为哪一张表创建触发器 WHEN 触发条件 --当该条件满足时，触发器才能执行 [FOR EACH ROW] --触发器为行级触发器，即对满足条件的记录触发执行一次 DECLARE \t声明部分 BEGIN \t主体部分 END; \n","categories":["DataBase"],"tags":["Oracle"]},{"title":"LinuxNotes","url":"http://www.xeby.me/2021/01/18/LinuxNotes/","content":"Zsh\nChinese Characters shows  in the form of it’s code as \\245  ,Zsh is to blame.\n\nAdd \nexport LC_ALL=en_US.UTF-8  export LANG=en_US.UTF-8 \nto .zshrc works.\nxfce4-terminal\nRandom error code on special chars.as ? or other unrecognized form.\n\nChange it’s encoding to Unicode-&gt;UTF 8works.\nLinux kernel(arch as an example)Change kernel\ninstall first.\nmake grub detect it.grub-mkconfig -o /boot/grub/grub.cfg\nReboot to target kernel.\nRemove unnessaries.Done\n\n\nRemove module from kernel.1.mkdir /etc/modprobe.d/vim /etc/modprobe.d/blacklist.confadd !xxxx to this file.\n* build the kernel from scratch works as well,but ….","categories":[],"tags":[]}]